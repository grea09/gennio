---
title: "2. Color"
author: Antoine Gréa
bibliography: bibliography/thesis.bib
style: thesis
---

# General Planning Framework




---


When making artificial inteligence systems, an important feature is the ability to make decisions and act accordingly. To act, one should plan ahead. This is why the field of automated planning is being actively researched in order to find efficient algorithms to find the best course of action in any given situation. The previous chapter allowed to lay the bases of knowledge representation. How knowledge about eh planning domains are represented is a main factor to take into account in order to choose any planning algorithm.

Automated planning really started being formally investigated after the creation of the Stanford Research Institute Problem Solver (STRIPS) by @fikes_strips_1971. This is one of the most influencial planner, not because of its algorithm but because of its input language. Any planning system needs a way to express the information related to the input problem. Any language done for this purpose is called an *action language*. STRIPS will be mostly remembered for its eponymous action language that is at the base of any modern derivatives.

All action language is based on mainly two notions: *actions* and *states*. A state is a set of *fluents* that describe aspects of the world modelized by the domain. Each action has a logic formula over states that allows its correct execution. This requirement is called *precondition*. The mirror image of this notion are possible *effects* which are logic formula that are enforced on the current state after the action is executed. The domain is completed with a problem, most of the time specified in a separate file. The problem basically contains two states: the *initial* and *goal* states.

## Classical Formalisms

One of the most comprehensive work on sumarizing the automated planning domain was done by @ghallab_automated_2004. This book explains the different planning paradigm of its time and gives formal description of some of them. This work has been updated later [@ghallab_automated_2016] to reflect the changes occuring in the planning community.

### State-transition planning

The most classical representation of automated planning is using the state graph approach: actions are operators on the set of states and a plan is a state automaton.

:::{.definition name="State-transition graph"}
is a graph $D=( \mathcal{S}, A )$ where $\mathcal{S}$ is the set of states used as vertices and $A$ is the set of action (also called state operators) used as edges. The adjacence function is also a state-transition function following the applicability of any action $a$ in any given state $s$. This means that $a \in \phi(s) \models a(s) \neq \emptyset$.
:::

We can see that problem description as several ways: either it is a finite-state automaton, a graph exploration problem or even a constraint satisfaction problem. In any way that problem is isomorph to its original formulation and most efficient algorithms use a derivative of A* exploration techniques on the state space.

Each state is usually composed of literals that are either functions or predicates describing the world. The expression of the $\phi$ function over actions gives a set of state the action is appliable in and the associated transformation of said state by the application of the action. These are usually logic formula over the states called preconditions and effects.

State based planning usually supose total knowledge of the state space and action behavior.
No concurency or time constraints are expressed and the state and action space must be finite as well as the resulting state graph. This process is also deterministic and doesn't allow uncertainty. The result of such a planning is a totally ordered sequence of actions called a plan. The total order needs to be enforced even if it is unecessary.

All those features are important in practice and lead to other planning paradigms that are more complex than classical state based planning.

### Plan space planning

Plan Space Planning (PSP) is a form of planning that use plan space as its search space. It starts with an empty plan and try to iteratively refine that plan into a solution. 

:::{.definition name="Plan Space refinement"}

:::


## General Formalism {#sec:formalism}

## Existing Languages and Frameworks

### Classical

After STRIPS, one of the first language to be introduced to express planning domains like ADL [@pednault_adl_1989]. That formalism adds negation and conjunction into literals to STRIPS. It also drops the closed world hypothesis for an open world one: anything not stated in conditions (initial or action effects) is unknown.

The current standard was strongly inspired by @penberthy_ucpop_1992 and his UCPOP planner. Like STRIPS, UCPOP had a planning domain language that was probably the most expressive of its time. It differs from ADL by merging the add and delete lists in effects and to change both preconditions and effects of actions into logic formula instead of simple states.

The PDDL language was created for the first major automated planning competition hosted by AIPS in 1998 [@ghallab_pddl_1998]. It came along with a syntax and solution checker writen in Lisp. It was introduced as a way to standardize notation of planning domains and problems so that libraries of standard problems can be used for benchmarks. The main goal of the language was to be able to express most of the planning problems of the time.

With time, the planning competitions became known under the name of International Planning Competitions (IPC) regularly hosted by the ICAPS conference. With each installment, the language evolved to address issues encountered the previous years. The current version of PDDL is 3.1 [@kovacs_bnf_2011]. Its syntax, goes similarly as described in @lst:pddl_syntax.

```{#lst:pddl_syntax .lisp caption="Simplified explanation of the syntax of PDDL." escapechar=$}
(define (domain <domain-name>)
  (:requirements :<requirement-name>)
  (:types <type-name>)
  (:constants <constant-name> - <constant-type>)
  (:predicates (<predicate-name> ?<var> - <var-type>))
  (:functions	(<function-name> ?<var> - <var-type>) - <function-type>)

  (:action <action-name>
	     :parameters (?<var> - <var-type>)
	     :precondition (and (= (<function-name> ?<var>) <value>) (<predicate-name> ?<var>))
	     :effect
	     (and (not (<predicate-name> ?<var>))
		   (assign (<function-name> ?<var>) ?<var>)))
```

PDDL uses the functional notation style of LISP. It defines usually two files: one for the domain and one for the problem instance. The domain describes constants, fluents and all possible actions. The problem lays the initial and goal states description.

For example, consider the classic block world domain expressed in @lst:block_pddl. It uses a predicate to express whether a block is on the table because several blocks can be on the table at once. However it uses a 0-ary function to describe the one block allowed to be held at a time. The description of the stack of blocks is done with an unary function to give the block that is on top of another one. To be able to express the absence of blocks it uses a constant named `no-block`. All the actions described are pretty straightforward: `stack` and `unstack` make sure it is possible to add or remove a block before doing it and `pick-up` and `put-down` manages the handling operations.

```{#lst:block_pddl .lisp caption="Classical PDDL 3.0 definition of the domain Block world" escapechar=$}
(define (domain BLOCKS-object-fluents)
  (:requirements :typing :equality :object-fluents)
  (:types block)
  (:constants no-block - block)
  (:predicates (on-table ?x - block))
  (:functions	(in-hand) - block
		(on-block ?x - block) - block) ;;what is in top of block ?x

  (:action pick-up
	     :parameters (?x - block)
	     :precondition (and (= (on-block ?x) no-block) (on-table ?x) (= (in-hand) no-block))
	     :effect
	     (and (not (on-table ?x))
		   (assign (in-hand) ?x)))

  (:action put-down
	     :parameters (?x - block)
	     :precondition (= (in-hand) ?x)
	     :effect
	     (and (assign (in-hand) no-block)
		   (on-table ?x)))

  (:action stack
	     :parameters (?x - block ?y - block)
	     :precondition (and (= (in-hand) ?x) (= (on-block ?y) no-block))
	     :effect
	     (and (assign (in-hand) no-block)
	   	  (assign (on-block ?y) ?x)))

  (:action unstack
	     :parameters (?x - block ?y - block)
	     :precondition (and (= (on-block ?y) ?x) (= (on-block ?x) no-block) (= (in-hand) no-block))
	     :effect
	     (and (assign (in-hand) ?x)
		  (assign (on-block ?y) no-block))))
```
However, PDDL is far from an universal standard. Some efforts have been made to try and standardize the domain of automated planning in the form of optional requirements. The latest of the PDDL standard is the version 3.1 [@kovacs_bnf_2011]. It has 18 atomic requirements as represented in @fig:pddl_req. Most requirements are parts of PDDL that either increase the complexity of planning significantly or that require extra implementation effort to meet.

![Dependancies and grouping of PDDL requirements.](graphics/pddl_requirements.svg){#fig:pddl_req}

Even with that flexibility, PDDL is unable to cover all of automated planning paradigms. This caused most subdomains of automated planning to be left in a state similar to before PDDL: a zoo of languages and derivatives that aren't interoperable. The reason for this is the fact that PDDL isn't expressive enough to encode more than a limited variation in action and fluent description.

Another problem is that PDDL isn't made to be used by planners to help with their planning process. Most planners will totally separate the compilation of PDDL before doing any planning, so much so that most planners of the latest IPC used a framework that translates PDDL into a useful form before planning, adding computation time to the planning process. The list of participating planners and their use of language is presented in @tbl:ipc.

Name          Trans Pre Lang     Base      Rank
----          ----- --- ----     ----      ----
Delfi         Yes   Yes C++      FD        1
Complementary Yes   Yes C++      FD        2
Planning-PDBs Yes   Yes C++      FD        3
Scorpion      Yes   Yes C++      FD        4
FDMS          Yes   Yes C++      FD        5
DecStar       Yes   Yes C++      LAMA      6
Metis         Yes   Yes C++      FD        7
MSP           Yes   Yes Lisp     FD        8
Symple        Yes   Yes C++      FD        9
Ma-plan       No    Yes C        None      10

: Planners participating in the Classic track of the 2018 International Planning Competition (IPC). The table states whether the planner used a translation and a preprocessing system to handle PDDL. Most of the planners are based on FastDownward directly. {#tbl:ipc}

The domain is so diverse that attempts to unify it haven't succeeded so far. The main reason behind this is that some paradigms are vastly different from the classical planning description. Sometimes just adding a seamingly small feature like probabilities or plan reuse can make for a totally different problem. In the next section we describe planning paradigms and how they differ from classical planning along with their associated languages.

### Temporality oriented

When planning, time can become a sensitve constraint. Some critical tasks may required to be completed within a certain time. Actions with durations are already a feature of PDDL 3.1. However, PDDL might not provide support for external events (i.e. events occuring independant from the agent). To do this one must use another language.

#### PDDL+

PDDL+ is an extension of PDDL 2.1 that handles process and events [@fox_pddl_2002]. It can be viewed as similar to PDDL 3.1 continious effects but it differs on the expressivity. A process can have an effect on fluents at any time. They can happen either from the agent's own doing or being purely environemental. It might be possible in certain cases to modelize this using the durative actions, continious effects and timed initial literals of PDDL 3.1.

In @lst:pddl_plus, we reproduce an example from @fox_pddl_2002. It shows the syntax of durative actions in PDDL+. The timed precondition are also available in PDDL 3.1, but the `increase` and `decrease` rate of fluents is an exclusive feature of PDDL+.

```{#lst:pddl_plus .lisp caption="Example of PDDL+ durative action from Fox's paper." escapechar=$}
(:durative-action downlink
    :parameters (?r - recorder ?g - groundStation)
    :duration (> ?duration 0)
    :condition (and (at start (inView ?g))
                    (over all (inView ?g))
                    (over all (> (data ?r) 0)))
    :effect (and (increase (downlinked)
                      (* #t (transmissionRate ?g)))
                 (decrease (data ?r)
                      (* #t (transmissionRate ?g)))))
```
The main issue with durative actions is that time becomes a continous ressource that may change the values of fluents. The search for a plan in that context has a higher complexity than regular planning.

### Probabilistic

Sometimes, acting can become unpredictable. An action can fail for many reasons, from logical errors down to physical constraints. This call for a way to plan using probabilities with the ability to recover from any predicted failures. PDDL doesn't support using probabilities. That is why all IPC's tracks dealing with it always used another language than PDDL.

#### PPDDL

PPDDL is such a language. It was used during the 4^th^ and 5^th IPC for its probabilistic track [@younes_ppddl_2004]. It allows for probabilistic effects as demonstrated in @lst:ppddl. The planner must take into account the probability when chosing an action. The plan must be the most likely to succeed. But even with the best plan, failure can occur. This is why probabilistic planning often gives policies instead of a plan. A policy dictates the best choice in any given state, failure or not. While this allows for much more resilient execution, computation of policies are exponentially harder than classical planning. Indeed the planner needs to take into account every outcome of every action in the plan and react accordingly.

```{#lst:ppddl .lisp caption="Example of PPDDL use of probabilistic effects from Younes' paper." escapechar=$}
(define (domain bomb-and-toilet)
    (:requirements :conditional-effects :probabilistic-effects)
    (:predicates (bomb-in-package ?pkg) (toilet-clogged)
                  (bomb-defused))
    (:action dunk-package
             :parameters (?pkg)
             :effect (and (when (bomb-in-package ?pkg)
                                (bomb-defused))
                          (probabilistic 0.05 (toilet-clogged)))))
```

#### RDDL

Another language used by the 7^th^ IPC's uncertainty track is RDDL [@sanner_relational_2010a]. This language has been choosen because of its ability to express problems that are hard to encode in PDDL or PPDDL. Indeed, RDDL is capable of expressing Partially Observable Markovian Decision Process (POMDP) and Dynamic Bayesian Networks (DBN) in planning domains. This along with complex probability laws allows for easy implementation of most probabilistic planning problems. Its syntax differs greatly from PDDL, and seems closer to scala or C++. 
An example is provided in @lst:rddl from @sanner_relational_2010a. In it, we can see that actions in RDDL doesn't need preconditions or effects. In that case the reward is the closest information to the classical goal and the action is simply a parameter that will influence the probability distribution of the events that conditioned the reward.

``` {#lst:rddl .cpp caption="Example of RDDL syntax by Sanner." escapechar=$}
////////////////////////////////////////////////////////////////////////
// A simple propositional 2-slice DBN (variables are not parameterized).
//
// Author: Scott Sanner (ssanner [at] gmail.com)
////////////////////////////////////////////////////////////////////////
domain prop_dbn {
  	
	requirements = { reward-deterministic };
      	
	pvariables { 
		p : { state-fluent,  bool, default = false };
		q : { state-fluent,  bool, default = false };
		r : { state-fluent,  bool, default = false }; 
		a : { action-fluent, bool, default = false }; 
	};
  
	cpfs {
		// Some standard Bernoulli conditional probability tables
		p´ = if (p ^ r) then Bernoulli(.9) else Bernoulli(.3);
						
		q´ = if (q ^ r) then Bernoulli(.9) 
						else if (a) then Bernoulli(.3) else Bernoulli(.8);

		// KronDelta is like a DiracDelta, but for discrete data (boolean or int)
		r´ = if (~q) then KronDelta(r) else KronDelta(r <=> q);										
	};

	// A boolean functions as a 0/1 integer when a numerical value is needed	
	reward = p + q - r; // a boolean functions as a 0/1 integer when a numerical value is needed
}
        
instance inst_dbn {

	domain = prop_dbn;	
	init-state { 
		p = true;  // could also just say 'p' by itself 
		q = false; // default so unnecessary, could also say '~q' by itself
		r;         // same as r = true
	};
  
	max-nondef-actions = 1;
	horizon  = 20;
	discount = 0.9;
}
```

### Multi-agent

Planning can also be a collective effort. In some cases, a system must account for other agents trying to either cooperate or compete in achieving similar goals. The problem that arise is coordination. How to make a plan meant to be executed with several agents concurently ? Several multi-agent action languages have been proposed to answer that question.

#### MAPL

Another extension of PDDL 2.1, MAPL was introduced to handle synchronization of actions [@brenner_multiagent_2003]. This is done using modal operators over fluents. In that regard, MAPL is closer to the PDDL+ extension proposed earlier. It introduce durative actions that will later be integrated into the PDDL 3.0 standard. MAPL also introduce a synchronization mechanism using speech as a comunication vector. This seems very specific as explicit comunication isn't a requirement of collaborative work. @Lst:mapl is an example of the syntax of MAPL domains. PDDL 3.0 seems to share a similar syntax.

``` {#lst:mapl .lisp caption="Example of MAPL syntax by Brenner." escapechar=$}
(:state-variables
  (pos ?a - agent) - location
  (connection ?p1 ?p2 - place) - road
  (clear ?r - road) - boolean)
(:durative-action Move
  :parameters (?a - agent ?dst - place)
  :duration (:= ?duration (interval 2 4))
  :condition
    (at start (clear (connection (pos ?a) ?dst)))
  :effect (and
    (at start (:= (pos ?a) (connection (pos ?a) ?dst)))
    (at end (:= (pos ?a) ?dst))))
```

#### MA-PDDL

Another aspect of multi-agent planning is the ability to affect tasks and to manage interactions between agents efficiently. For this MA-PDDL seems more adapted than MAPL. It is an extension of PDDL 3.1, that makes easier to plan for a team of heteroneous agents [@kovacs_multiagent_2012]. In the example in @lst:ma-pddl, we can see how action can be affected to agents. While it makes the representation easier, it is possible to obtain similar effect by passing an agent object as parameter of an action in PDDL 3.1. More complex expressions are possible in MA-PDDL, like referencing the action of other agents in the preconditions of actions or the ability to affect different goals to different agents. Later on, MA-PDDL was extended with probabilistic capabilities inspired by PPDDL [@kovacs_converting_2013].

``` {#lst:ma-pddl .lisp caption="Example of MA-PDDL syntax by Kovacs." escapechar=$}
(define (domain ma-lift-table)
(:requirements :equality :negative-preconditions 
               :existential-preconditions :typing :multi-agent) 
(:types agent) (:constants table)
(:predicates (lifted (?x - object) (at ?a - agent ?o - object))
(:action lift :agent ?a - agent :parameters ()
:precondition (and (not (lifted table)) (at ?a table) 
              (exists (?b - agent)
               (and (not (= ?a ?b)) (at ?b table) (lift ?b)))) 
:effect (lifted table)))
```

### Hierarchical

Another approach to planning is using Hierarchical Tasks Networks (HTN) to resolve some planning problem. Instead of searching to satisfy a goal, HTNs try to find a decomposition to a root task that fit the initial state requirements and that generate an executable plan.

#### UMCP

One of the first planner to support HTN domains was UCMP by @erol_umcp_1994. It uses Lisp like most of the early planning systems. Apparently PDDL was in part inspired by UCMP's syntax. Like for PDDL, the domain file describes action (called operators here) and their preconditions and effects (called postconditions). The syntax is demonstrated in @lst:ucmp. The interesting part of that language is the way decomposition is handled. Each task is expressed as a set of methods. Each method has an expansion expression that specifies how the plan should be constructed. It also has a pseudo precondition with modal operators on the temporality of the validity of the literals.

``` {#lst:ucmp .lisp caption="Example of the syntax used by UCMP." escapechar=$}
(constants a b c table) ; declare constant symbols
(predicates on clear) ; declare predicate symbols
(compound-tasks move) ; declare compound task symbols
(primitive-tasks unstack dostack restack) ; declare primitive task symbols
(variables x y z) ; declare variable symbols

(operator unstack(x y)
          :pre ((clear x)(on x y))
          :post ((~on x y)(on x table)(clear y)))
(operator dostack (x y)
          :pre ((clear x)(on x table)(clear y))
          :post ((~on x table)(on x y)(~clear y)))
(operator restack (x y z)
          :pre ((clear x)(on x y)(clear z))
          :post ((~on x y)(~clear z)(clear y)(on x z)))

(declare-method move(x y z)
                :expansion ((n restack x y z))
                :formula (and (not (veq y table))
                              (not (veq x table))
                              (not (veq z table))
                              (before (clear x) n)
                              (before (clear z) n)
                              (before (on x y) n)))

(declare-method move(x y z)
                :expansion ((n dostack x z))
                :formula (and (veq y table)
                              (before (clear x) n)
                              (before (on x y) n)))
```

#### SHOP2

The next HTN planner is SHOP2 by @nau_shop2_2003. It remains to this day, one of the reference implenentation of an HTN planner. The SHOP2 formalism is quite similar to UCMP's: each method has a signature, a precondition formula and eventually a decomposition description. This decomposition is a set of methods like in UCMP. The methods can be also partially ordered allowing more expressive plans. An example of the syntax of a method is given in @lst:shop2.

```{#lst:shop2 .lisp caption="Example of method in the SHOP2 language." escapechar=$}
(:method
  ; head
    (transport-person ?p ?c2)
  ; precondition
    (and
      (at ?p ?c1)
      (aircraft ?a)
      (at ?a ?c3)
      (different ?c1 ?c3))
  ; subtasks
    (:ordered
      (move-aircraft ?a ?c1)
      (board ?p ?a ?c1)
      (move-aircraft ?a ?c2)
      (debark ?p ?a ?c2)))
```

#### HDDL

A more recent example of HTN formalism comes from the PANDA framework by @bercher_hybrid_2014. This framework is considered the current standard of HTN planning and allows for great flexibility in domain description. PANDA takes previous formalism and generalize them into a new language exposed in @lst:hddl. That language was called HDDL after its most used file extention.

```{#lst:hddl .lisp caption="Example of HDDL syntax as used in the PANDA framework." escapechar=$}
(define (domain transport)
  (:requirements :typing :action-costs)
  (:types
        location target locatable - object
        vehicle package - locatable
        capacity-number - object
  )
  (:predicates 
     (road ?l1 ?l2 - location)
     (at ?x - locatable ?v - location)
     (in ?x - package ?v - vehicle)
     (capacity ?v - vehicle ?s1 - capacity-number)
     (capacity-predecessor ?s1 ?s2 - capacity-number)
  )

  (:task deliver :parameters (?p - package ?l - location))
  (:task unload :parameters (?v - vehicle ?l - location ?p - package))

  (:method m-deliver
    :parameters (?p - package ?l1 ?l2 - location ?v - vehicle)
    :task (deliver ?p ?l2)
     :ordered-subtasks (and
      (get-to ?v ?l1)
      (load ?v ?l1 ?p)
      (get-to ?v ?l2)
      (unload ?v ?l2 ?p))
  )
  (:method m-unload
    :parameters (?v - vehicle ?l - location ?p - package ?s1 ?s2 - capacity-number)
    :task (unload ?v ?l ?p)
    :subtasks (drop ?v ?l ?p ?s1 ?s2)
  )

  (:action drop
    :parameters (?v - vehicle ?l - location ?p - package ?s1 ?s2 - capacity-number)
    :precondition (and
        (at ?v ?l)
        (in ?p ?v)
        (capacity-predecessor ?s1 ?s2)
        (capacity ?v ?s1)
      )
    :effect (and
        (not (in ?p ?v))
        (at ?p ?l)
        (capacity ?v ?s2)
        (not (capacity ?v ?s1))
      )
  )
)
```

#### HPDDL

A very recent language proposition was done by @ramoul_mixedinitiative_2018. He proposes HPDDL with a simple syntax similar to the one of UCMP. In @lst:hpddl we give an example of HPDDL method. Its expressive power seems similar to that of UCMP and SHOP. Except for a possible commercial integration with PDDL4J [@pellier_pddl4j_2017], there doesn't seem to have any advantages compared to earlier works.

``` {#lst:hpddl .lisp caption="Example of HPDDL syntax as described by Ramoul." escapechar=$}
(:method do_navigate
  :parameters(?x - rover ?from ?to - waypoint)
  :expansion((tag t1 (navigate ?x ?from ?mid))
             (tag t2 (visit ?mid))
             (tag t3 (do_navigate ?x ?mid ?to))
             (tag t4 (unvisited ?mid)))
  :constraints((before (and (not (can_traverse ?x ?from ?to)) (not (visited ?mid))
                            (can_traverse ?x ?from ?mid)) t1)))
```

### Ontological

Another old idea was to merge automated planning and other artificial intelligence fields with knowledge representation and more specifically ontologies. Indeed, since the "semantic web" is already widespread for service description, why not make planning compatible with it to ease service composition ?

#### WebPDDL

This question finds it first answer in 2002 with WebPDDL. This language, explicited in @lst:webpddl, is meant to be compatible with RDF by using URI identifiers for domains [@mcdermott_representing_2002]. The syntax is inspired by PDDL, but axioms are added as constraints on the knowledge domain. Actions also have a return value and can have variables that aren't dependant on their parameters. This allows for greater expressivity than regular PDDL, but can be partially emulated using PDDL 3.1 constraints and object fluents.

```{#lst:webpddl .lisp caption="Example of WebPDDL syntax by Mc Dermott." escapechar=$}
(define (domain www-agents)
  (:extends (uri "http://www.yale.edu/domains/knowing")
            (uri "http://www.yale.edu/domains/regression-planning")
            (uri "http://www.yale.edu/domains/commerce"))
  (:requirements :existential-preconditions :conditional-effects)
  (:types Message - Obj Message-id - String)
  (:functions  (price-quote ?m - Money)
               (query-in-stock ?pid - Product-id)
               (reply-in-stock ?b - Boolean) - Message)
  (:predicates (web-agent ?x - Agent)
               (reply-pending a - Agent id - Message-id msg - Message)
               (message-exchange ?interlocutor - Agent
                                 ?sent ?received - Message
                                 ?eff - Prop)
               (expected-reply a - Agent sent expect-back - Message))
  (:axiom
      :vars (?agt - Agent ?msg-id - Message-id ?sent ?reply - Message)
      :implies (normal-step-value (receive ?agt ?msg-id) ?reply)
      :context (and (web-agent ?agt)
                    (reply-pending ?agt ?msg-id ?sent)
                    (expected-reply ?agt ?sent ?reply)))
  (:action send
      :parameters (?agt - Agent ?sent - Message)
      :value (?sid - Message-id)
      :precondition (web-agent ?agt)
      :effect (reply-pending ?agt ?sid ?sent))
  (:action receive
    :parameters (?agt - Agent ?sid - Message-id)
    :vars (?sent - Message ?eff - Prop)
    :precondition (and (web-agent ?agt) (reply-pending ?agt ?sid ?sent))
    :value (?received - Message)
    :effect (when (message-exchange ?agt ?sent ?received ?eff) ?eff)))
```

#### OPT

This previous work was updated by @mcdermott_opt_2005. The new version is called OPT and allows for some further expressivity. It can express hierarchical domains with links between actions and even advanced data structure. The syntax is mostly an update of WebPDDL. In @lst:opt, we can see that the URI were replaced by simpler names, the action notation was simplified to make the parameter and return value more natural. Axioms were replaced by facts with a different notation.

```{#lst:opt .lisp caption="Example of the updated OPT syntax as described by Mc Dermott." escapechar=$}
(define (domain www-agents)
  (:extends knowing regression-planning commerce)
  (:requirements :existential-preconditions :conditional-effects)
  (:types Message - Obj Message-id - String )
  (:type-fun (Key t) (Feature-type (keytype t)))
  (:type-fun (Key-pair t) (Tup (Key t) t))
  (:functions (price-quote ?m - Money)
              (query-in-stock ?pid - Product-id)
              (reply-in-stock ?b - Boolean) - Message)
  (:predicates (web-agent ?x - Agent)
               (reply-pending a - Agent id - Message-id msg - Message)
               (message-exchange ?interlocutor - Agent
                                 ?sent ?received - Message
                                 ?eff - Prop)
               (expected-reply a - Agent sent expect-back - Message))
  (:facts
    (freevars (?agt - Agent ?msg-id - Message-id
               ?sent ?reply - Message)
      (<- (and (web-agent ?agt)
               (reply-pending ?agt ?msg-id ?sent)
               (expected-reply ?agt ?sent ?reply))
               (normal-value (receive ?agt ?msg-id) ?reply))))
  (:action (send ?agt - Agent ?sent - Message) - (?sid - Message-id)
    :precondition (web-agent ?agt)
    :effect (reply-pending ?agt ?sid ?sent))
  (:action (receive ?agt - Agent ?sid - Message-id) - (?received - Message)
    :vars (?sent - Message ?eff - Prop)
    :precondition (and (web-agent ?agt)
                       (reply-pending ?agt ?sid ?sent))
    :effect (when (message-exchange ?agt ?sent ?received ?eff) ?eff)))
```

## Color and general planning representation

