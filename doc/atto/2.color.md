---
title: "2. Color"
author: Antoine Gréa
bibliography: bibliography/thesis.bib
style: thesis
---

# General Planning Framework

When making artificial inteligence systems, an important feature is the ability to make decisions and act accordingly. To act, one should plan ahead. This is why the field of automated planning is being actively researched in order to find efficient algorithms to find the best course of action in any given situation. The previous chapter allowed to lay the bases of knowledge representation. How knowledge about eh planning domains are represented is a main factor to take into account in order to choose any planning algorithm.

Automated planning really started being formally investigated after the creation of the Stanford Research Institute Problem Solver (STRIPS) by @fikes_strips_1971. This is one of the most influencial planner, not because of its algorithm but because of its input language. Any planning system needs a way to express the information related to the input problem. Any language done for this purpose is called an *action language*. STRIPS will be mostly remembered for its eponymous action language that is at the base of any modern derivatives.

Other languages were introduced to express planning domains like ADL [@pednault_adl_1989]. That formalism adds negation and conjunction into literals to STRIPS. It also drops the closed world hypothesis for an open world one: anything not stated in conditions (initial or action effects) is unknown.

The current standard was strongly inspired by @penberthy_ucpop_1992 and his UCPOP planner. Like STRIPS, UCPOP had a planning domain language that was probably the most expressive of its time. It differs from ADL by merging the add and delete lists in effects and to change both preconditions and effects of actions into logic formula instead of simple states.

All action language is based on mainly two notions: *actions* and *states*. A state is a set of *fluents* that describe aspects of the world modelized by the domain. Each action has a logic formula over states that allows its correct execution. This requirement is called *precondition*. The mirror image of this notion are possible *effects* which are logic formula that are enforced on the current state after the action is executed. The domain is completed with a problem, most of the time specified in a separate file. The problem basically contains two states: the *initial* and *goal* states. These definitions will be properly formalized in @sec:framework.

## Existing Languages and Frameworks

### PDDL

Nowadays, the language most recognised by the automated planning comunity is Planning Domain Definition Language (PDDL). It is strongly inspired by STRIPS and uses a Lisp-like syntax to express planning domains and problems.

This language was created for the first major automated planning competition hosted by AIPS in 1998 [@ghallab_pddl_1998]. It was introduced as a way to standardize notation of planning domains and problems so that libraries of standard problems can be used for benchmarks. The main goal of the language was to be able to express most of the planning problems of the time.

With time, the planning competitions became known under the name of International Planning Competitions (IPC) regularly hosted by the ICAPS conference. With each installment, the language evolved to address issues encountered the previous years. The current version of PDDL is 3.1 [@kovacs_bnf_2011]. Its syntax, goes as follows:

```{#lst:block_pddl .lisp caption="Classical PDDL 3.0 definition of the domain Block world" escapechar=$}
(define (domain BLOCKS-object-fluents)
  (:requirements :typing :equality :object-fluents)
  (:types block)

  (:constants no-block - block)

  (:predicates (on-table ?x - block))

  (:functions	(in-hand) - block
		(on-block ?x - block) - block) ;;what is in top of block ?x

  (:action pick-up
	     :parameters (?x - block)
	     :precondition (and (= (on-block ?x) no-block) (on-table ?x) (= (in-hand) no-block))
	     :effect
	     (and (not (on-table ?x))
		   (assign (in-hand) ?x)))

  (:action put-down
	     :parameters (?x - block)
	     :precondition (= (in-hand) ?x)
	     :effect
	     (and (assign (in-hand) no-block)
		   (on-table ?x)))

  (:action stack
	     :parameters (?x - block ?y - block)
	     :precondition (and (= (in-hand) ?x) (= (on-block ?y) no-block))
	     :effect
	     (and (assign (in-hand) no-block)
	   	  (assign (on-block ?y) ?x)))

  (:action unstack
	     :parameters (?x - block ?y - block)
	     :precondition (and (= (on-block ?y) ?x) (= (on-block ?x) no-block) (= (in-hand) no-block))
	     :effect
	     (and (assign (in-hand) ?x)
		  (assign (on-block ?y) no-block))))
```




---



Why PDDL ?
  Origin
  IPC

What is PDDL ?
  Syntax
  Examples
  Versions

Limits of PDDL


PDDL is far from an universal standard. Some efforts have been made to try and standardize the domain of automated planning in the form of optional requirements. The latest of the PDDL standard is the version 3.1 [@kovacs_bnf_2011]. It has 18 atomic requirements as represented in @fig:pddl_req. Most requirements are parts of PDDL that either increase the complexity of planning significantly or that require extra implementation effort to meet.

![Dependancies and grouping of PDDL requirements.](graphics/pddl_requirements.svg){#fig:pddl_req}

Even with that flexibility, PDDL is unable to cover all of automated planning systems. This caused most subdomains of automated planning to be left in a state similar to before PDDL: a zoo of languages and derivatives that aren't interoperable. The reason for this is the fact that PDDL isn't expressive enough to encode more than a limited variation in action and fluent description.

  Requirements
  Other paradigm
  
To illustrate the concrete use of SELF, we present an application to the domain of automated planning. In that field, the general consensius gravitated toward using the Planning Domain Definition Language (PDDL) as a standard to express planning domains. However, the comunity is very diverse and each planner use its own internal representation which created the needs for a dozen of specialized extensions to PDDL, as well as several revision and a zoo of unofficial derivated languages.

In some cases this standardization is almost impossible. As an example, Hierarchical Task Networks (HTN) is a planning technique that doesn't fit classical domain description in its standard form. HTN usually aren't goal driven and cannot insert actions (called tasks) arbitrarilly into plans but must conform to the task network structure through chosen decomposition operations. Any attempts at integrating HTN into PDDL in its entirety must rewrite completely the problem description as well as allow to encode plans into the domain description with all the possible orders and constraint paradigm used in practice.

Most planner engine need an external software or library to translate PDDL into a useable form. This means that planners are reasoning on a totally different language that has been preprocessed to remove anything that is deemed not useful for the direct resolution of that particular problem. While it is a good approach when optimizing for raw performance, it is catastrophic for any other criterias such as expressivity, and the flexibility of the plan and planning process. For example, such methods are so bad at repairing a plan that it is often better to replan from scratch. It is also impossible to take advantage of the semantic informations contained in the original description of the problem once this data is literally lost in translation.

Name          Trans Pre Lang     Base      Rank
----          ----- --- ----     ----      ----
Delfi         Yes   Yes C++      FD        1
Complementary Yes   Yes C++      FD        2
Planning-PDBs Yes   Yes C++      FD        3
Scorpion      Yes   Yes C++      FD        4
FDMS          Yes   Yes C++      FD        5
DecStar       Yes   Yes C++      LAMA      6
Metis         Yes   Yes C++      FD        7
MSP           Yes   Yes Lisp     FD        8
Symple        Yes   Yes C++      FD        9
Ma-plan       No    Yes C        None      10

: Planners participating in the Classic track of the 2018 International Planning Competition (IPC). The table states whether the planner used a translation and a preprocessing system to handle PDDL. Most of the planners are based on FastDownward directly.  {#tbl:ipc}

Those issues are what initially drove us to create SELF as a way to express domains, plans and any associated knowledge.

Implementations

Other frameworks

## Planning paradigms

### Classical

### Probabilistic

### Plan space

### Case based

### Hierarchical

Other ?



## General Planning Framework {#sec:framework}

First we need to formally define a planning framework that is as generalized as possible.

::: {.definition name="Fluent"} :::
A planning fluent $f$ is a parameterized entity $r(arg_1, arg_2, …, arg_n)$ where:

* $r \in R$ is a relation/function.
* $arg_{i \in [1,n]} \in \mathcal{E}$ are the arguments (possibly quantified).
* $n = |r|$ is the arity of $r$.

Fluents are signed. Negative fluents are noted $\neg f$ and behave as a logical complement. The quantifiers are affected by the sign of the fluents. We do not use the closed SELF hypothesis: fluents are only satisfied when another compatible fluent is provided. Sets of fluents have a boolean value that equals the conjunction of all its fluents.
:::::::::::::::::::::::::::::::::::

If $|r| = 2$ a fluent using $r$ can be expressed as a statement. Otherwise, it is represented as a parameterized entity. We use the exclusive quantifier for negation. For simplicity we will use list as conjonction formula (since it is the most used relation in planning).

::: {.definition #def:action name="Action"} :::
An action is a parametrized tuple $a(args)=\langle \nu, pre, \mathit{eff}, ¢, d, prob, methods \rangle$ where:

* $\nu$ holds the **name** of the action.
* $\mathit{pre}$ and $\mathit{eff}$ are sets of fluents that are respectively the **preconditions and the effects** of the action.
* $¢$ is the intrisic **cost** of the action.
* $d$ is the intrinsic **duration** of the action.
* $prob$ is the prior **probability** of the action succeeding.
* $methods$ is a set of **methods** that decompose the action into smaller simpler ones.
::::::::::::::::::::::::::::::::::::::::::::::::::

Operators take many names in difference planning paradigm : actions, steps, tasks, etc. In our case we call operators, all fully lifted actions and actions are all the instances possibles (including operators).

::: {.definition name="Partial Plan / Method"} :::
A partially ordered plan is an *acyclic* directed graph $\pi = (A_\pi, L)$, with:

* $A_\pi$ the set of **steps** of the plan as vertices. A step is an action belonging in the plan. $A_\pi$ must contain an initial step $I_\pi$ and goal step $G_\pi$ as convinience for certain planning paradigms.
* $L$ the set of **causal links** of the plan as edges.
We note $l = a_s \xrightarrow{c} a_t$ the link between its source $a_s$ and its target $a_t$ caused by the set of fluents $c$. If $c = \emptyset$ then the link is used as an ordering constraint.
:::::::::::::::::::::::::::::::::

This definition can express any kind of plans, either temporal, fully or partially ordered or even lose hierarchical plans (using the methods of the actions).

::: {.definition name="Problem"} :::
The planning problem is defined as the **root operator** $a_0$ which methods are potential solutions of the problem. Its preconditions and effects are respectively used as initial state and goal description.
::::::::::::::::::::::::::::::::::::

This problem description allows for all planning paradigm known to the authors.

### Action type

(Définition)

### Plan type

(Définition)

### Problem type

(Définition)


## Using SELF for planning

In order to describe this planning framework into SELF, we simply put all fields of the actions into properties. Entities are used as fluents, and the entire knwoledge domain as constraints. We use parameterized types as specified @before.

```{#lst:planning .java caption="Content of the file \"planning.w\""}
"lang.w" = ? ; //include vanilla SELF
(pre,eff)::Property(Action,Group);
(¢,d,prob) ::Property(Action,Float);
methods ::Property(Action,Plan);
Plan = Group(Statement);
-> ::Property(Action,Action);
Fluent = Entity;
```

### Equivalence

A first example of how SELF can be used to replace PDDL takes place using the well known 'block SELF' planning domain from the IPCs.



And here is its equivalent in SELF :

```{#lst:block_SELF .java caption="BlockSELF in SELF"}
"planning.w" = ? ; //include base terminology

(! on !, held(!), down(_)) :: Fluent;

pickUp(x) pre (~ on x, down(x), held(~));
pickUp(x) eff (~(down(x)), held(~));

putDown(x) pre (held(x));
putDown(x) eff (held(~), down(x));

stack(x, y) pre (held(x), ~ on y);
stack(x, y) eff (held(~), x on y);

unstack(x, y) pre (held(~), x on y);
unstack(x, y) eff (held(x), ~ on y);
```

The functions in PDDL are replaced by parameterized entities with a unicity constraint on the parameter (only one instance can be true at once). If the value of the function is needed one can simply use the solution quantifier to retrieve the value. 

In this example, the `no-block` constant is replaced by the exclusive quantifier. Since the domain has one type, it isn't required to define it as all objects of the domains are compatible with all fluents. The predicate `on-table` is replaced with the unary predicate `down`. The function `in-hand` is replaced with the unary exclusive predicate `held`. For the unary function `on-block` we use a binary property `on` used in a statement.



### Differences with PDDL

SELF is more consice than PDDL. It will infere most types and declaration. Variables are also infered if they are used more than once in a statement and also part of parameters.

While PDDL uses a fixed set of extensions to specify the capabilities of the domain, SELF uses inclusion of other files to allow for greater flexibility. In PDDL, everything must be declared while in SELF, type inference allows for usage without definition. It is interesting to note that the use of variables names `x` and `y` are arbitrary and can be changed for each statement and the domain will still be functionally the same. The line 3 in @lst:block_pddl is a specific feature of SELF that is absent in PDDL. It is possible to specify constraints on the cardinality of properties. This limits the number of different combination of values that can be true at once. This is typically done in PDDL using several predicate or constraints.

Most of the differences can be sumarized saying that 'SELF do it once, PDDL needs it twice'. This doesn't only mean that SELF is more compact but also that the expressivity allows for a drastic reduction of the search space if taken into account. @thiebaux_defense_2005 advocate for the recognition of the fact that expressivity isn't just a convinience but is crucial for some problem and that treating it like an obstacle by trying to compile it away only makes the problem worse. If a planner is agnostic to the domain and problem, it cannot take advantages of clues that the instanciation of an action or even its name can hold [@babli_use_2015].

Whatever the time and work that an expert spend on a planning domain it will always be incomplete and fixed. SELF allows for dynamical extension and even adresses the use of reified actions as parameters. Such a framework can be useful in multi-agent systems where agents can commnicate composite actions to instruct another agent. It can also be useful for macro-action learning that allows to learn hierarchical domains from repeating observations. It can also be used in online planning to repair a plan that failed. And at last this mechanism can be used for explanation or inference by making easy to map two similar domains together. (lots of @citation).

Also another difference between SELF and PDDL is the underlying planning framework. We presented the one of SELF but PDDL seems to suppose a more classical state based formalism. For example the fluents are of two kind depending if they are used as precondition or effects. In the first case, the fluent is a formula that is evaluated like a predicate to know if the action can be executed in any given state. Effects are formula enforcing the values of existing fluent in the state. SELF just suppose that the new knowledge is enforcing and that the fluents are of the same kind since verification about the coherence of the actions are made prior to its application in planning.
